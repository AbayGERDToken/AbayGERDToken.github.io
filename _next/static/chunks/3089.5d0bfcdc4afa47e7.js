"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[3089],{53089:function(e,t,i){i.d(t,{createMipd:function(){return v},injectedEvmConnector:function(){return u}});var n=i(56127),r=i(6827),o=i(44015),c=i(56344),s=i(95693),a=i(43280),d=i(17360),h=i(20840);class l extends o.C{constructor(e){super(e),(0,n.Z)(this,"connectorNamespace",c.$.EIP155),(0,n.Z)(this,"currentChainNamespace",s.E.EIP155),(0,n.Z)(this,"type",a.$Y.EXTERNAL),(0,n.Z)(this,"name",void 0),(0,n.Z)(this,"isInjected",!0),(0,n.Z)(this,"status",a.Ak.NOT_READY),(0,n.Z)(this,"injectedProvider",null),this.name=e.name,this.injectedProvider=e.provider,this.icon=e.icon}get provider(){return this.status!==a.Ak.NOT_READY&&this.injectedProvider?this.injectedProvider:null}set provider(e){throw Error("Not implemented")}async init(e){await super.init(e);let t=this.coreOptions.chains.find(t=>t.chainId===e.chainId);super.checkInitializationRequirements({chainConfig:t}),this.status=a.Ak.READY,this.emit(a.cS.READY,this.name);try{if(d.c.debug(`initializing ${this.name} injected connector`),e.autoConnect&&(this.rehydrated=!0,!await this.connect({chainId:e.chainId,getIdentityToken:e.getIdentityToken})))throw this.rehydrated=!1,h.RM.connectionError("Failed to rehydrate.")}catch(e){this.emit(a.cS.REHYDRATION_ERROR,e)}}async connect({chainId:e,getIdentityToken:t}){if(super.checkConnectionRequirements(),!this.injectedProvider)throw h.RM.connectionError("Injected provider is not available");let i=this.coreOptions.chains.find(t=>t.chainId===e);if(!i)throw h.RM.connectionError("Chain config is not available");this.status=a.Ak.CONNECTING,this.emit(a.cS.CONNECTING,{connector:this.name});try{let e;if(await this.injectedProvider.request({method:"eth_requestAccounts"}),this.injectedProvider.chainId!==i.chainId)try{await this.switchChain(i,!0)}catch{await this.addChain(i,!0),await this.switchChain(i,!0)}this.status=a.Ak.CONNECTED;let n=e=>{if(0===e.length){var t;this.disconnect(),null!==(t=this.injectedProvider)&&void 0!==t&&t.removeListener&&this.injectedProvider.removeListener("accountsChanged",n)}};return this.injectedProvider.on("accountsChanged",n),this.emit(a.cS.CONNECTED,{connector:this.name,reconnected:this.rehydrated,provider:this.injectedProvider,identityTokenInfo:e}),t&&(e=await this.getIdentityToken()),this.injectedProvider}catch(e){if(this.status=a.Ak.READY,this.rehydrated||this.emit(a.cS.ERRORED,e),this.rehydrated=!1,e instanceof h.up)throw e;throw h.RM.connectionError(`Failed to login with ${this.name} injected wallet`)}}async disconnect(e={cleanup:!1}){if(!this.injectedProvider)throw h.RM.connectionError("Injected provider is not available");await super.disconnectSession(),void 0!==this.injectedProvider.removeAllListeners&&this.injectedProvider.removeAllListeners();try{await this.injectedProvider.request({method:"wallet_revokePermissions",params:[{eth_accounts:{}}]})}catch{}e.cleanup?(this.status=a.Ak.NOT_READY,this.injectedProvider=null):this.status=a.Ak.READY,await super.disconnect()}async getUserInfo(){if(!this.canAuthorize)throw h.RM.notConnectedError("Not connected with wallet, Please login/connect first");return{}}async addChain(e,t=!1){if(!this.injectedProvider)throw h.RM.connectionError("Injected provider is not available");await this.injectedProvider.request({method:"wallet_addEthereumChain",params:[{chainId:e.chainId,chainName:e.displayName,rpcUrls:[e.rpcTarget],blockExplorerUrls:[e.blockExplorerUrl],nativeCurrency:{name:e.tickerName,symbol:e.ticker,decimals:e.decimals||18},iconUrls:[e.logo]}]})}async switchChain(e,t=!1){if(!this.injectedProvider)throw h.RM.connectionError("Injected provider is not available");super.checkSwitchChainRequirements(e,t),await this.injectedProvider.request({method:"wallet_switchEthereumChain",params:[{chainId:e.chainId}]})}async enableMFA(){throw Error("Method Not implemented")}async manageMFA(){throw Error("Method Not implemented")}}let u=e=>({coreOptions:t})=>new l({name:(0,r.rB)(e.info.name),provider:e.provider,icon:e.info.icon,coreOptions:t});function v(){let e=new Set,t=[],i=()=>(function(e){if("undefined"==typeof window)return;let t=t=>e(t.detail);return window.addEventListener("eip6963:announceProvider",t),window.dispatchEvent(new CustomEvent("eip6963:requestProvider")),()=>window.removeEventListener("eip6963:announceProvider",t)})(i=>{t.some(({info:e})=>e.uuid===i.info.uuid)||(t=[...t,i],e.forEach(e=>e(t,{added:[i]})))}),n=i();return{_listeners:()=>e,clear(){e.forEach(e=>e([],{removed:[...t]})),t=[]},destroy(){this.clear(),e.clear(),n?.()},findProvider:({rdns:e})=>t.find(t=>t.info.rdns===e),getProviders:()=>t,reset(){this.clear(),n?.(),n=i()},subscribe:(i,{emitImmediately:n}={})=>(e.add(i),n&&i(t,{added:t}),()=>e.delete(i))}}}}]);